{"version":3,"sources":["../src/occurence.js"],"names":["setObjectBasedOnFullPath","require","Occurence","constructor","nn","EventedProperty","name","fullPath","eventedProperty","eventedPropertyActionFunc","action","handleAction","Proxy","handler","get","parentEventedPropertyActionFunc","parentEventedProperty","eventedProperties","undefined","callbacks","calculateFullPath","fullPathNames","split","fire","data","context","i","len","length","setObject","objectToSet","on","value","omit","remainingFullPathNames","callback","push","off","bind","callbackIndex","indexOf","splice","rest","result","console","error","calculatedFullPath","separator","firstFullPathName","setValueBasedOnType","nameOfPropertyToSet","secondFullPathName","discard","Array","isArray"],"mappings":"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","file":"occurence.js","sourcesContent":["//if Proxy is not natively supported, ensure polyfill is created.\nrequire('../vendor/reflect');\n\nexport class Occurence{\n  constructor(){\n    return nn(new EventedProperty({name:'', fullPath:''}));\n  }\n}\n\nconst nn = (eventedProperty)=>{\n  // console.log(`nn called with: `, eventedProperty);\n\n  //when a property is invoked as a function, pass the call down to EventedProperty.handleAction, which will use passed\n  //in data to determine which action to perform (fire, on, off)\n  //e.g. eventbus.person.name({fire:'some data'}) will invoke this function.\n  let eventedPropertyActionFunc = (action)=>{\n    return eventedProperty.handleAction(action);\n  };\n  //attach eventedProperty so proxy has access.\n  eventedPropertyActionFunc.eventedProperty = eventedProperty;\n\n  //intercept all property access on the wrappedValue function-object\n  return new Proxy(eventedPropertyActionFunc, handler);\n};\n\nconst handler = {\n\n  get: function(parentEventedPropertyActionFunc, name){\n    let parentEventedProperty = parentEventedPropertyActionFunc.eventedProperty;\n    // console.log(`parentEventedProperty is: `, parentEventedProperty);\n    // console.log(`name being accessed is: `, name);\n\n    //create a new evented property with the accessed name, if one doesn't already exist.\n    if(parentEventedProperty.eventedProperties[name] === undefined){\n      parentEventedProperty.eventedProperties[name] = new EventedProperty({name, parentEventedProperty});\n    }\n\n    let eventedProperty = parentEventedProperty.eventedProperties[name];\n\n    //wrap the eventedProperty with trigger function\n    return nn(eventedProperty);\n  },\n};\n\nclass EventedProperty{\n  constructor({parentEventedProperty, name, fullPath}){\n    this.callbacks = [];\n    this.fullPath =  calculateFullPath({parentEventedProperty, name, fullPath});\n    this.fullPathNames = this.fullPath.split('.');\n    this.name = name;\n    this.eventedProperties = {};\n    this.parentEventedProperty = parentEventedProperty;\n  }\n\n  /**\n   *\n   * @param data - data to be sent to each callback.\n   * @param context - when child is fired, we want the parent to have access to the fullPath, etc. of the child.\n   * e.g. eventbus.person.on((data, {fullPath})=>{...})   eventbus.person.name(fire:'jason')\n   *      should result in person.on fullPath == 'person.name';\n   */\n  fire(data, {context}){\n    context = context || this;\n    // console.log(`${this.fullPath} triggered with data: `, data);\n    for(let i = 0, len=this.callbacks.length; i < len; ++i){\n      this.callbacks[i](data, context);\n    }\n    if(this.parentEventedProperty){\n      this.parentEventedProperty.fire(data, {context});\n    }\n  }\n\n  setObject(objectToSet){\n    // this.objectToSet = objectToSet;\n    this.on((value, {fullPathNames})=>{\n      //omit the first fullPathName, since that represents the objectToSet.\n      //e.g. eventBus.person({objectToSet: person});\n      let [omit, ...remainingFullPathNames] = fullPathNames;\n      setObjectBasedOnFullPath({objectToSet, fullPathNames: remainingFullPathNames, value});\n    });\n  }\n  //todo: once\n  on(callback){\n    this.callbacks.push(callback);\n    let off = function(){\n      return this.off(callback);\n    }.bind(this);\n    return off;\n  }\n  off(callback){\n    let callbackIndex = this.callbacks.indexOf(callback);\n    // console.log(`off removing callback at index`, callbackIndex);\n    if(callbackIndex < 0){return;}\n    this.callbacks.splice(callbackIndex, 1);\n    return callback;\n  }\n\n  handleAction(action){\n    let {on, off, fire, setObject, ...rest} = action;\n    let result;\n    switch(true){\n      case on != undefined:\n        result = this.on(on, rest);\n        break;\n      case off !== undefined:\n        this.off(off, rest);\n        break;\n      case fire !== undefined:\n        result = this.fire(fire, rest);\n        break;\n      case setObject !== undefined:\n        result = this.setObject(setObject);\n        break;\n      default:\n        console.error('invalid action: ', action);\n    }\n    return result;\n  }\n}\n\n/**\n * the base evented property is the EventBus, which has a blank name and fullpath, so we don't want to include it in our event string names.\n * @param parentEventedProperty\n * @param name\n * @param fullPath\n * @returns {*}\n */\nfunction calculateFullPath({parentEventedProperty, name, fullPath}){\n  if(fullPath){\n    return fullPath;\n  }\n  let calculatedFullPath;\n  if(parentEventedProperty !== undefined){\n    let separator = parentEventedProperty.fullPath !== '' ? '.' : '';\n    calculatedFullPath = `${parentEventedProperty.fullPath}${separator}${name}`;\n  }else{\n    calculatedFullPath = name;\n  }\n  return calculatedFullPath;\n}\n\n/**\n *\n * @param objectToSet\n * @param fullPathNames - e.g. ['person', 'name']\n * @param value - e.g. 'jason'\n */\nexport function setObjectBasedOnFullPath({objectToSet, fullPathNames, value}){\n  if(fullPathNames.length == 0){\n    objectToSet = value;\n    return;\n  }\n\n  //ensure there is something to set\n  let firstFullPathName = fullPathNames[0];\n\n  if(fullPathNames.length == 1){\n    setValueBasedOnType({objectToSet, nameOfPropertyToSet: firstFullPathName, value});\n  }else if(fullPathNames.length == 2){\n    //just set the value\n    objectToSet[firstFullPathName] = objectToSet[firstFullPathName] || {}; //ensure the property exists.\n    let secondFullPathName = fullPathNames[1];\n    setValueBasedOnType({objectToSet: objectToSet[firstFullPathName], nameOfPropertyToSet: secondFullPathName, value});\n  }else{\n    let [discard, ...remainingFullPathNames] = fullPathNames;\n    setObjectBasedOnFullPath({objectToSet: objectToSet[firstFullPathName], fullPathNames:remainingFullPathNames, value});\n  }\n}\n\nfunction setValueBasedOnType({objectToSet, nameOfPropertyToSet, value}){\n  if(Array.isArray(objectToSet[nameOfPropertyToSet])){\n    objectToSet[nameOfPropertyToSet].push(value);\n  }else{\n    objectToSet[nameOfPropertyToSet] = value;\n  }\n}"]}