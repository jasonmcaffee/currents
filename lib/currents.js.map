{"version":3,"sources":["../src/currents.js"],"names":["setObjectBasedOnFullPath","require","Currents","constructor","setObject","result","nn","EventedProperty","name","fullPath","undefined","eventedProperty","eventedPropertyActionFunc","action","handleAction","Proxy","handler","get","parentEventedPropertyActionFunc","parentEventedProperty","eventedProperties","callbacks","calculateFullPath","fullPathNames","split","fire","data","context","i","len","length","objectToSet","on","value","omit","remainingFullPathNames","callback","push","off","bind","callbackIndex","indexOf","splice","rest","console","error","calculatedFullPath","separator","firstFullPathName","setValueBasedOnType","nameOfPropertyToSet","secondFullPathName","discard","Array","isArray"],"mappings":"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","file":"currents.js","sourcesContent":["//if Proxy is not natively supported, ensure polyfill is created.\nrequire('../vendor/reflect');\n\nexport class Currents{\n  constructor({setObject}={}){\n    let result = nn(new EventedProperty({name:'', fullPath:''}));\n    if(setObject !== undefined){\n      result({setObject});\n    }\n    return result;\n  }\n}\n\nconst nn = (eventedProperty)=>{\n  // console.log(`nn called with: `, eventedProperty);\n\n  //when a property is invoked as a function, pass the call down to EventedProperty.handleAction, which will use passed\n  //in data to determine which action to perform (fire, on, off)\n  //e.g. occurence.person.name({fire:'some data'}) will invoke this function.\n  let eventedPropertyActionFunc = (action)=>{\n    return eventedProperty.handleAction(action);\n  };\n  //attach eventedProperty so proxy has access.\n  eventedPropertyActionFunc.eventedProperty = eventedProperty;\n\n  //intercept all property access on the wrappedValue function-object\n  return new Proxy(eventedPropertyActionFunc, handler);\n};\n\nconst handler = {\n\n  get: function(parentEventedPropertyActionFunc, name){\n    let parentEventedProperty = parentEventedPropertyActionFunc.eventedProperty;\n    // console.log(`parentEventedProperty is: `, parentEventedProperty);\n    // console.log(`name being accessed is: `, name);\n\n    //create a new evented property with the accessed name, if one doesn't already exist.\n    if(parentEventedProperty.eventedProperties[name] === undefined){\n      parentEventedProperty.eventedProperties[name] = new EventedProperty({name, parentEventedProperty});\n    }\n\n    let eventedProperty = parentEventedProperty.eventedProperties[name];\n\n    //wrap the eventedProperty with trigger function\n    return nn(eventedProperty);\n  },\n};\n\nclass EventedProperty{\n  constructor({parentEventedProperty, name, fullPath}){\n    this.callbacks = [];\n    this.fullPath =  calculateFullPath({parentEventedProperty, name, fullPath});\n    this.fullPathNames = this.fullPath.split('.');\n    this.name = name;\n    this.eventedProperties = {};\n    this.parentEventedProperty = parentEventedProperty;\n  }\n\n  /**\n   *\n   * @param data - data to be sent to each callback.\n   * @param context - when child is fired, we want the parent to have access to the fullPath, etc. of the child.\n   * e.g. occurence.person.on((data, {fullPath})=>{...})   occurence.person.name(fire:'jason')\n   *      should result in person.on fullPath == 'person.name';\n   */\n  fire(data, {context}){\n    context = context || this;\n    // console.log(`${this.fullPath} triggered with data: `, data);\n    for(let i = 0, len=this.callbacks.length; i < len; ++i){\n      this.callbacks[i](data, context);\n    }\n    if(this.parentEventedProperty){\n      this.parentEventedProperty.fire(data, {context});\n    }\n  }\n\n  setObject(objectToSet){\n    // this.objectToSet = objectToSet;\n    this.on((value, {fullPathNames})=>{\n      //omit the first fullPathName, since that represents the objectToSet.\n      //e.g. eventBus.person({objectToSet: person});\n      let [omit, ...remainingFullPathNames] = fullPathNames;\n      fullPathNames = remainingFullPathNames;\n      setObjectBasedOnFullPath({objectToSet, fullPathNames, value});\n    });\n  }\n  //todo: once\n  on(callback){\n    this.callbacks.push(callback);\n    let off = function(){\n      return this.off(callback);\n    }.bind(this);\n    return off;\n  }\n  off(callback){\n    let callbackIndex = this.callbacks.indexOf(callback);\n    // console.log(`off removing callback at index`, callbackIndex);\n    if(callbackIndex < 0){return;}\n    this.callbacks.splice(callbackIndex, 1);\n    return callback;\n  }\n\n  handleAction(action){\n    let {on, off, fire, setObject, ...rest} = action;\n    let result;\n    switch(true){\n      case on != undefined:\n        result = this.on(on, rest);\n        break;\n      case off !== undefined:\n        this.off(off, rest);\n        break;\n      case fire !== undefined:\n        result = this.fire(fire, rest);\n        break;\n      case setObject !== undefined:\n        result = this.setObject(setObject);\n        break;\n      default:\n        console.error('invalid action: ', action);\n    }\n    return result;\n  }\n}\n\n/**\n * the base evented property is the EventBus, which has a blank name and fullpath, so we don't want to include it in our event string names.\n * @param parentEventedProperty\n * @param name\n * @param fullPath\n * @returns {*}\n */\nfunction calculateFullPath({parentEventedProperty, name, fullPath}){\n  if(fullPath){\n    return fullPath;\n  }\n  let calculatedFullPath;\n  if(parentEventedProperty !== undefined){\n    let separator = parentEventedProperty.fullPath !== '' ? '.' : '';\n    calculatedFullPath = `${parentEventedProperty.fullPath}${separator}${name}`;\n  }else{\n    calculatedFullPath = name;\n  }\n  return calculatedFullPath;\n}\n\n/**\n * todo: if value is an object, recursively grab it props and set. don't just assign value directly.\n * @param objectToSet\n * @param fullPathNames - e.g. ['person', 'name']\n * @param value - e.g. 'jason'\n */\nexport function setObjectBasedOnFullPath({objectToSet, fullPathNames, value}){\n  if(fullPathNames.length == 0){\n    objectToSet = value;\n    return;\n  }\n\n  //ensure there is something to set\n  let firstFullPathName = fullPathNames[0];\n\n  if(fullPathNames.length == 1){\n    setValueBasedOnType({objectToSet, nameOfPropertyToSet: firstFullPathName, value});\n  }else if(fullPathNames.length == 2){\n    //just set the value\n    objectToSet[firstFullPathName] = objectToSet[firstFullPathName] || {}; //ensure the property exists.\n    let secondFullPathName = fullPathNames[1];\n    setValueBasedOnType({objectToSet: objectToSet[firstFullPathName], nameOfPropertyToSet: secondFullPathName, value});\n  }else{\n    let [discard, ...remainingFullPathNames] = fullPathNames;\n    setObjectBasedOnFullPath({objectToSet: objectToSet[firstFullPathName], fullPathNames:remainingFullPathNames, value});\n  }\n}\n\nfunction setValueBasedOnType({objectToSet, nameOfPropertyToSet, value}){\n  if(Array.isArray(objectToSet[nameOfPropertyToSet])){\n    objectToSet[nameOfPropertyToSet].push(value);\n  }else{\n    objectToSet[nameOfPropertyToSet] = value;\n  }\n}"]}